## ## ## ## ## ## ## ## ## ## ## ## ##
## How is JavaScript code executed? ##
## ## ## ## ## ## ## ## ## ## ## ## ##
JavaScript code is executed in a two-step process: compilation and execution. This process is known as the JavaScript runtime environment. Let's break down how JavaScript code is executed:

1. **Compilation:**
   When you load a web page that contains JavaScript code, the browser's JavaScript engine (e.g., V8 in Chrome, SpiderMonkey in Firefox) first goes through a compilation phase. During this phase, the JavaScript code is parsed and transformed into an intermediate representation called "bytecode" or "machine code." This bytecode is optimized for execution and is much faster to run than the original source code.

   The compilation phase involves several steps, including:

   - Tokenization: Breaking the source code into meaningful chunks called "tokens."
   - Parsing: Creating an abstract syntax tree (AST) to represent the structure of the code.
   - Compilation: Generating bytecode or machine code from the AST.

2. **Execution:**
   After compilation, the generated bytecode or machine code is executed by the JavaScript engine. This execution happens within a runtime environment, which includes the following components:

   - Call Stack: A data structure that keeps track of the currently executing functions. Functions are pushed onto the stack as they are called and popped off when they complete.
   - Memory Heap: An area where variables, objects, and closures are stored.
   - Event Loop: In environments like web browsers, an event loop is responsible for handling asynchronous operations, such as timers, network requests, and user interactions.

   The JavaScript engine follows a single-threaded event-driven model, meaning that it can only execute one piece of code at a time. However, it manages asynchronous operations through the event loop, which allows non-blocking execution.

   As code is executed, functions are added to the call stack, and when they complete, they are removed from the stack. If a function encounters asynchronous operations, they are moved to a separate task queue. The event loop continuously checks the task queue and transfers tasks to the call stack when it's empty.

In summary, JavaScript code is compiled into optimized bytecode or machine code, which is then executed within a runtime environment. The event loop manages asynchronous tasks and ensures that JavaScript remains responsive even when dealing with non-blocking operations. Understanding this process is crucial for writing efficient and responsive JavaScript code.

## ## ## ## ## ## ## ## ## 
## Execution of JS Code ##
## ## ## ## ## ## ## ## ## 

Absolutely, you've got the basic concepts right! Let's break down the execution process in JavaScript using the Global Execution Context, Function Execution Context, and Eval Execution Context:

**1. Memory Creation Phase (Creation Phase):**
In this phase, JavaScript allocates memory for variables and function declarations before executing the code. The memory is set up for variables, functions, and their arguments, but their values are not assigned yet. This ensures that variables and functions are accessible throughout the entire scope where they are declared.

For example, in the code:
```javascript
function greet(name) {
  console.log("Hello, " + name);
}
var age = 30;
```

During the Memory Creation Phase:
- Memory is allocated for the function `greet` and the variable `age`.
- The `name` parameter is set up within the function's execution context.

**2. Execution Phase:**
In this phase, JavaScript executes the code line by line, performing operations and assigning values to variables. It follows these steps:

1. **Global Execution Context:**
   - The Global Execution Context is created initially, and `this` is assigned.
   - The code inside the Global Execution Context starts executing line by line.

2. **Function Execution Context:**
   - When a function is called, a new Function Execution Context is created.
   - Memory is allocated for local variables and function arguments.
   - The function's code starts executing within this context.
   - Any nested functions or inner scopes create their own execution contexts, forming a chain.

3. **Eval Execution Context:**
   - This context is created when using the `eval()` function to execute code passed as a string.
   - It's similar to a function execution context, but for dynamically evaluated code.

During the Execution Phase:
- Values are assigned to variables, based on assignments and calculations.
- Functions are executed when called, and their execution context is created.
- When a function is done executing, its context is popped off the stack.

The Execution Contexts work in a stack-like manner, with the Global Execution Context at the bottom, and the most recently invoked function at the top. When a function completes execution, its context is removed from the stack, and the control goes back to the previous context.

It's important to note that JavaScript is single-threaded and follows an event-driven model, which allows it to handle asynchronous operations efficiently, such as those involving timers or network requests, through mechanisms like the event loop.

Understanding these concepts is crucial for tracing the flow of your code, handling scope, and knowing how variables and functions are managed during different phases of execution.

```javascript
let val1 = 10;
let val2 = 5;
function addNum(num1, num2) {
  let total = num1 + num2;
  return total;
}

let result1 = addNum(val1, val2);
let result2 = addNum(10, 2);
```
- Explaination:

1. You've declared two variables `val1` and `val2` with values `10` and `5` respectively.

2. You've defined a function `addNum` that takes two parameters (`num1` and `num2`). Inside the function, you add the two numbers together and store the result in a variable `total`. Then you return this `total`.

3. You're using the `addNum` function to perform calculations and store the results in the variables `result1` and `result2`.

4. When the code starts executing, it goes through these steps:

   - First, it remembers the existence of `val1`, `val2`, and `addNum` (this is the Memory Phase).
   - Then, it starts executing the code line by line (Execution Phase).

5. It assigns the values `10` and `5` to `val1` and `val2` respectively.

6. When `addNum(val1, val2)` is executed, a new "Execution Context" is created for the function call. This context has its own memory to store variables (`num1`, `num2`, `total`), separate from the global context. The code inside the function is executed within this context.

7. Inside the function, it adds `num1` and `num2` (which are `10` and `5`) and stores the result `15` in the `total` variable. Then it returns this `total`.

8. The returned `total` value (`15`) is assigned to `result1` in the global context.

9. Similarly, when `addNum(10, 2)` is executed, a new Execution Context is created. Inside this context, `num1` is `10`, `num2` is `2`, and the result `12` is returned and assigned to `result2` in the global context.

10. The program has now executed all the code, and the variables `result1` and `result2` contain the calculated values `15` and `12` respectively.

11. After the function calls are completed, the Execution Contexts created for them are deleted.

In summary, JavaScript goes through a process of remembering variables, executing code, and managing different contexts to perform calculations and store results in variables. This understanding is important for tracing the flow of your code and knowing how data is processed and manipulated.

## ## ## ## ## ## ## ## ## ##
## CallStack in JavaScript ##
## ## ## ## ## ## ## ## ## ##

The call stack is a fundamental concept in JavaScript's runtime environment that helps manage the execution of functions in a program. It keeps track of the currently executing functions and their execution context. Each time a function is called, a new frame is added to the call stack, and when a function completes its execution, its frame is removed from the stack. This creates a "stack" of function calls, hence the term "call stack."

Let's break down how the call stack works:

1. **Function Calls and Frames:**
   When a function is called, a new frame is created and pushed onto the call stack. This frame contains information about the function's parameters, local variables, and its position in the code.

2. **Execution:**
   The function at the top of the call stack is the one currently being executed. The JavaScript engine executes the code within this function's frame. If the function calls other functions, their frames are added to the top of the stack.

3. **Function Completion:**
   When a function completes its execution, its frame is removed from the top of the call stack, and the control moves to the function below it. The process continues until the stack is empty.

4. **Stack Overflow:**
   If the call stack becomes too deep due to excessive function calls (for example, in cases of infinite recursion), a "stack overflow" error occurs. This happens because the call stack has a limited amount of memory.

Here's a simple example to illustrate the call stack:

```javascript
function first() {
  console.log("First function");
  second();
}

function second() {
  console.log("Second function");
}

first();
```

In this example, when `first()` is called, its frame is added to the call stack. Inside `first()`, `second()` is called, so its frame is added on top. When `second()` completes, its frame is removed, and then `first()` completes and is removed as well.

Understanding the call stack is essential for debugging, as it helps you visualize the order of function execution and track the sequence of function calls. It's also important to note that JavaScript follows a single-threaded model, so the call stack processes one function at a time, while asynchronous operations are managed through mechanisms like the event loop and callback functions.
